"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/hooks/useDatabase.ts":
/*!**********************************!*\
  !*** ./src/hooks/useDatabase.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAchievements: function() { return /* binding */ useAchievements; },\n/* harmony export */   useAnalytics: function() { return /* binding */ useAnalytics; },\n/* harmony export */   useAuditLogs: function() { return /* binding */ useAuditLogs; },\n/* harmony export */   useCategories: function() { return /* binding */ useCategories; },\n/* harmony export */   useCertificates: function() { return /* binding */ useCertificates; },\n/* harmony export */   useCourses: function() { return /* binding */ useCourses; },\n/* harmony export */   useInstructors: function() { return /* binding */ useInstructors; },\n/* harmony export */   useUserProgress: function() { return /* binding */ useUserProgress; },\n/* harmony export */   useUsers: function() { return /* binding */ useUsers; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/api */ \"./src/lib/api.ts\");\n/* harmony import */ var _data_mockData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../data/mockData */ \"./src/data/mockData.ts\");\n// Custom hook for database operations\n// This hook provides easy access to database operations throughout the app\n\n\n\n// Custom hook for courses\nconst useCourses = ()=>{\n    const [courses, setCourses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [featuredCourses, setFeaturedCourses] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllCourses = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.courseAPI.getAllCourses();\n            // Transform backend data to frontend format\n            const transformedCourses = data.map((course)=>({\n                    id: course.id,\n                    title: course.title,\n                    instructor: {\n                        id: course.instructor_id || \"unknown\",\n                        name: course.instructor_name || \"Unknown Instructor\",\n                        title: course.instructor_title || \"Instructor\",\n                        image: course.instructor_image || \"/placeholder-avatar.jpg\",\n                        bio: course.instructor_bio || \"Experienced instructor\",\n                        email: course.instructor_email || \"instructor@forwardafrica.com\",\n                        expertise: course.instructor_expertise ? JSON.parse(course.instructor_expertise) : [\n                            \"Education\"\n                        ],\n                        experience: course.instructor_experience || 5,\n                        createdAt: new Date(course.instructor_created_at || Date.now())\n                    },\n                    instructorId: course.instructor_id,\n                    category: course.category_name || course.category || \"General\",\n                    thumbnail: course.thumbnail || \"/placeholder-course.jpg\",\n                    banner: course.banner || \"/placeholder-course.jpg\",\n                    videoUrl: course.video_url,\n                    description: course.description || \"Course description coming soon.\",\n                    lessons: course.lessons || [],\n                    featured: course.featured || false,\n                    totalXP: course.total_xp || 1000,\n                    comingSoon: course.coming_soon || false,\n                    releaseDate: course.release_date\n                }));\n            setCourses(transformedCourses);\n        } catch (err) {\n            console.error(\"Failed to fetch courses from API, using mock data:\", err);\n            const mockCourses = (0,_data_mockData__WEBPACK_IMPORTED_MODULE_2__.getAllCourses)();\n            setCourses(mockCourses);\n            setError(\"Failed to load courses from server\");\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    const fetchFeaturedCourses = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.courseAPI.getFeaturedCourses();\n            // Transform backend data to frontend format\n            const transformedCourses = data.map((course)=>({\n                    id: course.id,\n                    title: course.title,\n                    instructor: {\n                        id: course.instructor_id || \"unknown\",\n                        name: course.instructor_name || \"Unknown Instructor\",\n                        title: course.instructor_title || \"Instructor\",\n                        image: course.instructor_image || \"/placeholder-avatar.jpg\",\n                        bio: course.instructor_bio || \"Experienced instructor\",\n                        email: course.instructor_email || \"instructor@forwardafrica.com\",\n                        expertise: course.instructor_expertise ? JSON.parse(course.instructor_expertise) : [\n                            \"Education\"\n                        ],\n                        experience: course.instructor_experience || 5,\n                        createdAt: new Date(course.instructor_created_at || Date.now())\n                    },\n                    instructorId: course.instructor_id,\n                    category: course.category_name || course.category || \"General\",\n                    thumbnail: course.thumbnail || \"/placeholder-course.jpg\",\n                    banner: course.banner || \"/placeholder-course.jpg\",\n                    videoUrl: course.video_url,\n                    description: course.description || \"Course description coming soon.\",\n                    lessons: course.lessons || [],\n                    featured: course.featured || false,\n                    totalXP: course.total_xp || 1000,\n                    comingSoon: course.coming_soon || false,\n                    releaseDate: course.release_date\n                }));\n            setFeaturedCourses(transformedCourses);\n        } catch (err) {\n            console.error(\"Failed to fetch featured courses from API, using mock data:\", err);\n            const mockFeaturedCourses = (0,_data_mockData__WEBPACK_IMPORTED_MODULE_2__.getFeaturedCourses)();\n            setFeaturedCourses(mockFeaturedCourses);\n        }\n    }, []);\n    return {\n        courses,\n        featuredCourses,\n        loading,\n        error,\n        fetchAllCourses,\n        fetchFeaturedCourses\n    };\n};\n// Custom hook for audit logs\nconst useAuditLogs = ()=>{\n    const [logs, setLogs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAuditLogs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (filters)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.auditLogsAPI.getAuditLogs(filters);\n            setLogs(data);\n        } catch (err) {\n            console.error(\"Failed to fetch audit logs:\", err);\n            setError(\"Failed to load audit logs\");\n            setLogs([]);\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    const createAuditLog = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (auditData)=>{\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.auditLogsAPI.createAuditLog(auditData);\n            // Refresh logs after creating new one\n            await fetchAuditLogs();\n        } catch (err) {\n            console.error(\"Failed to create audit log:\", err);\n            throw err;\n        }\n    }, [\n        fetchAuditLogs\n    ]);\n    return {\n        logs,\n        loading,\n        error,\n        fetchAuditLogs,\n        createAuditLog\n    };\n};\n// Custom hook for categories\nconst useCategories = ()=>{\n    const [categories, setCategories] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllCategories = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.categoryAPI.getAllCategories();\n            setCategories(data);\n        } catch (err) {\n            console.error(\"Failed to fetch categories:\", err);\n            setError(\"Failed to load categories\");\n            setCategories([]);\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    return {\n        categories,\n        loading,\n        error,\n        fetchAllCategories\n    };\n};\n// Custom hook for instructors\nconst useInstructors = ()=>{\n    const [instructors, setInstructors] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllInstructors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.instructorAPI.getAllInstructors();\n            setInstructors(data);\n        } catch (err) {\n            console.error(\"Failed to fetch instructors:\", err);\n            setError(\"Failed to load instructors\");\n            setInstructors([]);\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    return {\n        instructors,\n        loading,\n        error,\n        fetchAllInstructors\n    };\n};\n// Hook for managing user progress\nconst useUserProgress = (userId)=>{\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchUserProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!userId) return;\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.progressAPI.getAllUserProgress(userId);\n            setProgress(data);\n        } catch (err) {\n            setError(\"Failed to fetch user progress\");\n            console.error(\"Error fetching user progress:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        userId\n    ]);\n    const updateProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (courseId, progressData)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.progressAPI.updateProgress(userId, courseId, progressData);\n            await fetchUserProgress(); // Refresh data\n        } catch (err) {\n            setError(\"Failed to update progress\");\n            console.error(\"Error updating progress:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        userId,\n        fetchUserProgress\n    ]);\n    const createProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (progressData)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.progressAPI.createProgress(progressData);\n            await fetchUserProgress(); // Refresh data\n        } catch (err) {\n            setError(\"Failed to create progress\");\n            console.error(\"Error creating progress:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        fetchUserProgress\n    ]);\n    return {\n        progress,\n        loading,\n        error,\n        fetchUserProgress,\n        updateProgress,\n        createProgress\n    };\n};\n// Hook for managing certificates\nconst useCertificates = (userId)=>{\n    const [certificates, setCertificates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchUserCertificates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!userId) return;\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.certificateAPI.getUserCertificates(userId);\n            setCertificates(data);\n        } catch (err) {\n            setError(\"Failed to fetch certificates\");\n            console.error(\"Error fetching certificates:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        userId\n    ]);\n    const verifyCertificate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (verificationCode)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.certificateAPI.verifyCertificate(verificationCode);\n            return data;\n        } catch (err) {\n            setError(\"Failed to verify certificate\");\n            console.error(\"Error verifying certificate:\", err);\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    return {\n        certificates,\n        loading,\n        error,\n        fetchUserCertificates,\n        verifyCertificate\n    };\n};\n// Hook for managing achievements\nconst useAchievements = (userId)=>{\n    const [achievements, setAchievements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchUserAchievements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (!userId) return;\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.achievementAPI.getUserAchievements(userId);\n            setAchievements(data);\n        } catch (err) {\n            setError(\"Failed to fetch achievements\");\n            console.error(\"Error fetching achievements:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        userId\n    ]);\n    return {\n        achievements,\n        loading,\n        error,\n        fetchUserAchievements\n    };\n};\n// Hook for managing users\nconst useUsers = ()=>{\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // Changed to any[] as User type is removed\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchAllUsers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.userAPI.getUsers();\n            setUsers(data);\n        } catch (err) {\n            setError(\"Failed to fetch users\");\n            console.error(\"Error fetching users:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    const fetchUserById = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (userId)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.userAPI.getUser(userId);\n            return data;\n        } catch (err) {\n            setError(\"Failed to fetch user\");\n            console.error(\"Error fetching user:\", err);\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    const createUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (userData)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const result = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.userAPI.createUser(userData);\n            await fetchAllUsers(); // Refresh data\n            return result;\n        } catch (err) {\n            setError(\"Failed to create user\");\n            console.error(\"Error creating user:\", err);\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        fetchAllUsers\n    ]);\n    const updateUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (userId, userData)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            await _lib_api__WEBPACK_IMPORTED_MODULE_1__.userAPI.updateUser(userId, userData);\n            await fetchAllUsers(); // Refresh data\n        } catch (err) {\n            setError(\"Failed to update user\");\n            console.error(\"Error updating user:\", err);\n        } finally{\n            setLoading(false);\n        }\n    }, [\n        fetchAllUsers\n    ]);\n    return {\n        users,\n        loading,\n        error,\n        fetchAllUsers,\n        fetchUserById,\n        createUser,\n        updateUser\n    };\n};\n// Hook for platform analytics\nconst useAnalytics = ()=>{\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [detailedStats, setDetailedStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const fetchPlatformStats = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            console.log(\"\\uD83D\\uDCCA Fetching platform stats...\");\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.analyticsAPI.getPlatformStats();\n            console.log(\"\\uD83D\\uDCCA Platform stats received:\", data);\n            setStats(data);\n        } catch (err) {\n            setError(\"Failed to fetch platform stats\");\n            console.error(\"Error fetching platform stats:\", err);\n            // Set fallback data\n            setStats({\n                totalUsers: 0,\n                totalCourses: 0,\n                totalLessons: 0,\n                totalCertificates: 0,\n                totalInstructors: 0,\n                completedCourses: 0,\n                activeStudents: 0,\n                totalXP: 0\n            });\n        } finally{\n            setLoading(false);\n        }\n    }, []);\n    const fetchDetailedAnalytics = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        try {\n            const data = await _lib_api__WEBPACK_IMPORTED_MODULE_1__.analyticsAPI.getDetailedAnalytics();\n            setDetailedStats(data);\n        } catch (err) {\n            console.error(\"Failed to fetch detailed analytics:\", err);\n            setError(\"Failed to load detailed analytics\");\n        }\n    }, []);\n    return {\n        stats,\n        detailedStats,\n        loading,\n        error,\n        fetchPlatformStats,\n        fetchDetailedAnalytics\n    };\n}; // Example usage in components:\n /*\r\nimport { useCourses, useUserProgress } from '../hooks/useDatabase';\r\n\r\nconst HomePage = () => {\r\n  const { featuredCourses, loading, fetchFeaturedCourses } = useCourses();\r\n  const { progress, fetchUserProgress } = useUserProgress(userId);\r\n\r\n  useEffect(() => {\r\n    fetchFeaturedCourses();\r\n    fetchUserProgress();\r\n  }, []);\r\n\r\n  if (loading) return <div>Loading...</div>;\r\n\r\n  return (\r\n    <div>\r\n      {featuredCourses.map(course => (\r\n        <CourseCard key={course.id} course={course} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n*/ \n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHckIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDc0IsT0FBT0MsU0FBUyxHQUFHdkIsK0NBQVFBLENBQWdCO0lBRWxELE1BQU1pSSxxQkFBcUJoSSxrREFBV0EsQ0FBQztRQUNyQ29CLFdBQVc7UUFDWEUsU0FBUztRQUNULElBQUk7WUFDRjhDLFFBQVE2RCxHQUFHLENBQUM7WUFDWixNQUFNekcsT0FBTyxNQUFNakIsa0RBQVlBLENBQUMySCxnQkFBZ0I7WUFDaEQ5RCxRQUFRNkQsR0FBRyxDQUFDLHlDQUErQnpHO1lBQzNDcUcsU0FBU3JHO1FBQ1gsRUFBRSxPQUFPMkMsS0FBSztZQUNaN0MsU0FBUztZQUNUOEMsUUFBUS9DLEtBQUssQ0FBQyxrQ0FBa0M4QztZQUNoRCxvQkFBb0I7WUFDcEIwRCxTQUFTO2dCQUNQTSxZQUFZO2dCQUNaQyxjQUFjO2dCQUNkQyxjQUFjO2dCQUNkQyxtQkFBbUI7Z0JBQ25CQyxrQkFBa0I7Z0JBQ2xCQyxrQkFBa0I7Z0JBQ2xCQyxnQkFBZ0I7Z0JBQ2hCNUUsU0FBUztZQUNYO1FBQ0YsU0FBVTtZQUNSekMsV0FBVztRQUNiO0lBQ0YsR0FBRyxFQUFFO0lBRUwsTUFBTXNILHlCQUF5QjFJLGtEQUFXQSxDQUFDO1FBQ3pDLElBQUk7WUFDRixNQUFNd0IsT0FBTyxNQUFNakIsa0RBQVlBLENBQUNvSSxvQkFBb0I7WUFDcERaLGlCQUFpQnZHO1FBQ25CLEVBQUUsT0FBTzJDLEtBQUs7WUFDWkMsUUFBUS9DLEtBQUssQ0FBQyx1Q0FBdUM4QztZQUNyRDdDLFNBQVM7UUFDWDtJQUNGLEdBQUcsRUFBRTtJQUVMLE9BQU87UUFDTHNHO1FBQ0FFO1FBQ0EzRztRQUNBRTtRQUNBMkc7UUFDQVU7SUFDRjtBQUNGLEVBQUUsQ0FFRiwrQkFBK0I7Q0FDL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZURhdGFiYXNlLnRzPzc3Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VzdG9tIGhvb2sgZm9yIGRhdGFiYXNlIG9wZXJhdGlvbnNcclxuLy8gVGhpcyBob29rIHByb3ZpZGVzIGVhc3kgYWNjZXNzIHRvIGRhdGFiYXNlIG9wZXJhdGlvbnMgdGhyb3VnaG91dCB0aGUgYXBwXHJcblxyXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgY291cnNlQVBJLCBjYXRlZ29yeUFQSSwgaW5zdHJ1Y3RvckFQSSwgcHJvZ3Jlc3NBUEksIGNlcnRpZmljYXRlQVBJLCBhY2hpZXZlbWVudEFQSSwgYW5hbHl0aWNzQVBJLCB1c2VyQVBJLCBhdWRpdExvZ3NBUEkgfSBmcm9tICcuLi9saWIvYXBpJztcclxuaW1wb3J0IHsgQ291cnNlLCBDYXRlZ29yeSwgSW5zdHJ1Y3RvciwgVXNlclByb2dyZXNzLCBDZXJ0aWZpY2F0ZSwgQWNoaWV2ZW1lbnQgfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7IGdldEFsbENvdXJzZXMgYXMgZ2V0TW9ja0NvdXJzZXMsIGdldEZlYXR1cmVkQ291cnNlcyBhcyBnZXRNb2NrRmVhdHVyZWRDb3Vyc2VzIH0gZnJvbSAnLi4vZGF0YS9tb2NrRGF0YSc7XHJcblxyXG4vLyBDdXN0b20gaG9vayBmb3IgY291cnNlc1xyXG5leHBvcnQgY29uc3QgdXNlQ291cnNlcyA9ICgpID0+IHtcclxuICBjb25zdCBbY291cnNlcywgc2V0Q291cnNlc10gPSB1c2VTdGF0ZTxDb3Vyc2VbXT4oW10pO1xyXG4gIGNvbnN0IFtmZWF0dXJlZENvdXJzZXMsIHNldEZlYXR1cmVkQ291cnNlc10gPSB1c2VTdGF0ZTxDb3Vyc2VbXT4oW10pO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IGZldGNoQWxsQ291cnNlcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgY291cnNlQVBJLmdldEFsbENvdXJzZXMoKTtcclxuXHJcbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIGRhdGEgdG8gZnJvbnRlbmQgZm9ybWF0XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ291cnNlcyA9IGRhdGEubWFwKChjb3Vyc2U6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogY291cnNlLmlkLFxyXG4gICAgICAgIHRpdGxlOiBjb3Vyc2UudGl0bGUsXHJcbiAgICAgICAgaW5zdHJ1Y3Rvcjoge1xyXG4gICAgICAgICAgaWQ6IGNvdXJzZS5pbnN0cnVjdG9yX2lkIHx8ICd1bmtub3duJyxcclxuICAgICAgICAgIG5hbWU6IGNvdXJzZS5pbnN0cnVjdG9yX25hbWUgfHwgJ1Vua25vd24gSW5zdHJ1Y3RvcicsXHJcbiAgICAgICAgICB0aXRsZTogY291cnNlLmluc3RydWN0b3JfdGl0bGUgfHwgJ0luc3RydWN0b3InLFxyXG4gICAgICAgICAgaW1hZ2U6IGNvdXJzZS5pbnN0cnVjdG9yX2ltYWdlIHx8ICcvcGxhY2Vob2xkZXItYXZhdGFyLmpwZycsXHJcbiAgICAgICAgICBiaW86IGNvdXJzZS5pbnN0cnVjdG9yX2JpbyB8fCAnRXhwZXJpZW5jZWQgaW5zdHJ1Y3RvcicsXHJcbiAgICAgICAgICBlbWFpbDogY291cnNlLmluc3RydWN0b3JfZW1haWwgfHwgJ2luc3RydWN0b3JAZm9yd2FyZGFmcmljYS5jb20nLFxyXG4gICAgICAgICAgZXhwZXJ0aXNlOiBjb3Vyc2UuaW5zdHJ1Y3Rvcl9leHBlcnRpc2UgPyBKU09OLnBhcnNlKGNvdXJzZS5pbnN0cnVjdG9yX2V4cGVydGlzZSkgOiBbJ0VkdWNhdGlvbiddLFxyXG4gICAgICAgICAgZXhwZXJpZW5jZTogY291cnNlLmluc3RydWN0b3JfZXhwZXJpZW5jZSB8fCA1LFxyXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjb3Vyc2UuaW5zdHJ1Y3Rvcl9jcmVhdGVkX2F0IHx8IERhdGUubm93KCkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0cnVjdG9ySWQ6IGNvdXJzZS5pbnN0cnVjdG9yX2lkLFxyXG4gICAgICAgIGNhdGVnb3J5OiBjb3Vyc2UuY2F0ZWdvcnlfbmFtZSB8fCBjb3Vyc2UuY2F0ZWdvcnkgfHwgJ0dlbmVyYWwnLFxyXG4gICAgICAgIHRodW1ibmFpbDogY291cnNlLnRodW1ibmFpbCB8fCAnL3BsYWNlaG9sZGVyLWNvdXJzZS5qcGcnLFxyXG4gICAgICAgIGJhbm5lcjogY291cnNlLmJhbm5lciB8fCAnL3BsYWNlaG9sZGVyLWNvdXJzZS5qcGcnLFxyXG4gICAgICAgIHZpZGVvVXJsOiBjb3Vyc2UudmlkZW9fdXJsLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBjb3Vyc2UuZGVzY3JpcHRpb24gfHwgJ0NvdXJzZSBkZXNjcmlwdGlvbiBjb21pbmcgc29vbi4nLFxyXG4gICAgICAgIGxlc3NvbnM6IGNvdXJzZS5sZXNzb25zIHx8IFtdLFxyXG4gICAgICAgIGZlYXR1cmVkOiBjb3Vyc2UuZmVhdHVyZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgdG90YWxYUDogY291cnNlLnRvdGFsX3hwIHx8IDEwMDAsXHJcbiAgICAgICAgY29taW5nU29vbjogY291cnNlLmNvbWluZ19zb29uIHx8IGZhbHNlLFxyXG4gICAgICAgIHJlbGVhc2VEYXRlOiBjb3Vyc2UucmVsZWFzZV9kYXRlXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHNldENvdXJzZXModHJhbnNmb3JtZWRDb3Vyc2VzKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY291cnNlcyBmcm9tIEFQSSwgdXNpbmcgbW9jayBkYXRhOicsIGVycik7XHJcbiAgICAgIGNvbnN0IG1vY2tDb3Vyc2VzID0gZ2V0TW9ja0NvdXJzZXMoKTtcclxuICAgICAgc2V0Q291cnNlcyhtb2NrQ291cnNlcyk7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjb3Vyc2VzIGZyb20gc2VydmVyJyk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IGZldGNoRmVhdHVyZWRDb3Vyc2VzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNvdXJzZUFQSS5nZXRGZWF0dXJlZENvdXJzZXMoKTtcclxuXHJcbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIGRhdGEgdG8gZnJvbnRlbmQgZm9ybWF0XHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ291cnNlcyA9IGRhdGEubWFwKChjb3Vyc2U6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogY291cnNlLmlkLFxyXG4gICAgICAgIHRpdGxlOiBjb3Vyc2UudGl0bGUsXHJcbiAgICAgICAgaW5zdHJ1Y3Rvcjoge1xyXG4gICAgICAgICAgaWQ6IGNvdXJzZS5pbnN0cnVjdG9yX2lkIHx8ICd1bmtub3duJyxcclxuICAgICAgICAgIG5hbWU6IGNvdXJzZS5pbnN0cnVjdG9yX25hbWUgfHwgJ1Vua25vd24gSW5zdHJ1Y3RvcicsXHJcbiAgICAgICAgICB0aXRsZTogY291cnNlLmluc3RydWN0b3JfdGl0bGUgfHwgJ0luc3RydWN0b3InLFxyXG4gICAgICAgICAgaW1hZ2U6IGNvdXJzZS5pbnN0cnVjdG9yX2ltYWdlIHx8ICcvcGxhY2Vob2xkZXItYXZhdGFyLmpwZycsXHJcbiAgICAgICAgICBiaW86IGNvdXJzZS5pbnN0cnVjdG9yX2JpbyB8fCAnRXhwZXJpZW5jZWQgaW5zdHJ1Y3RvcicsXHJcbiAgICAgICAgICBlbWFpbDogY291cnNlLmluc3RydWN0b3JfZW1haWwgfHwgJ2luc3RydWN0b3JAZm9yd2FyZGFmcmljYS5jb20nLFxyXG4gICAgICAgICAgZXhwZXJ0aXNlOiBjb3Vyc2UuaW5zdHJ1Y3Rvcl9leHBlcnRpc2UgPyBKU09OLnBhcnNlKGNvdXJzZS5pbnN0cnVjdG9yX2V4cGVydGlzZSkgOiBbJ0VkdWNhdGlvbiddLFxyXG4gICAgICAgICAgZXhwZXJpZW5jZTogY291cnNlLmluc3RydWN0b3JfZXhwZXJpZW5jZSB8fCA1LFxyXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShjb3Vyc2UuaW5zdHJ1Y3Rvcl9jcmVhdGVkX2F0IHx8IERhdGUubm93KCkpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpbnN0cnVjdG9ySWQ6IGNvdXJzZS5pbnN0cnVjdG9yX2lkLFxyXG4gICAgICAgIGNhdGVnb3J5OiBjb3Vyc2UuY2F0ZWdvcnlfbmFtZSB8fCBjb3Vyc2UuY2F0ZWdvcnkgfHwgJ0dlbmVyYWwnLFxyXG4gICAgICAgIHRodW1ibmFpbDogY291cnNlLnRodW1ibmFpbCB8fCAnL3BsYWNlaG9sZGVyLWNvdXJzZS5qcGcnLFxyXG4gICAgICAgIGJhbm5lcjogY291cnNlLmJhbm5lciB8fCAnL3BsYWNlaG9sZGVyLWNvdXJzZS5qcGcnLFxyXG4gICAgICAgIHZpZGVvVXJsOiBjb3Vyc2UudmlkZW9fdXJsLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBjb3Vyc2UuZGVzY3JpcHRpb24gfHwgJ0NvdXJzZSBkZXNjcmlwdGlvbiBjb21pbmcgc29vbi4nLFxyXG4gICAgICAgIGxlc3NvbnM6IGNvdXJzZS5sZXNzb25zIHx8IFtdLFxyXG4gICAgICAgIGZlYXR1cmVkOiBjb3Vyc2UuZmVhdHVyZWQgfHwgZmFsc2UsXHJcbiAgICAgICAgdG90YWxYUDogY291cnNlLnRvdGFsX3hwIHx8IDEwMDAsXHJcbiAgICAgICAgY29taW5nU29vbjogY291cnNlLmNvbWluZ19zb29uIHx8IGZhbHNlLFxyXG4gICAgICAgIHJlbGVhc2VEYXRlOiBjb3Vyc2UucmVsZWFzZV9kYXRlXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHNldEZlYXR1cmVkQ291cnNlcyh0cmFuc2Zvcm1lZENvdXJzZXMpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBmZWF0dXJlZCBjb3Vyc2VzIGZyb20gQVBJLCB1c2luZyBtb2NrIGRhdGE6JywgZXJyKTtcclxuICAgICAgY29uc3QgbW9ja0ZlYXR1cmVkQ291cnNlcyA9IGdldE1vY2tGZWF0dXJlZENvdXJzZXMoKTtcclxuICAgICAgc2V0RmVhdHVyZWRDb3Vyc2VzKG1vY2tGZWF0dXJlZENvdXJzZXMpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNvdXJzZXMsXHJcbiAgICBmZWF0dXJlZENvdXJzZXMsXHJcbiAgICBsb2FkaW5nLFxyXG4gICAgZXJyb3IsXHJcbiAgICBmZXRjaEFsbENvdXJzZXMsXHJcbiAgICBmZXRjaEZlYXR1cmVkQ291cnNlc1xyXG4gIH07XHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEN1c3RvbSBob29rIGZvciBhdWRpdCBsb2dzXHJcbmV4cG9ydCBjb25zdCB1c2VBdWRpdExvZ3MgPSAoKSA9PiB7XHJcbiAgY29uc3QgW2xvZ3MsIHNldExvZ3NdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICBjb25zdCBmZXRjaEF1ZGl0TG9ncyA9IHVzZUNhbGxiYWNrKGFzeW5jIChmaWx0ZXJzPzoge1xyXG4gICAgYWN0aW9uPzogc3RyaW5nO1xyXG4gICAgcmVzb3VyY2VfdHlwZT86IHN0cmluZztcclxuICAgIHVzZXJfaWQ/OiBzdHJpbmc7XHJcbiAgICBzdGFydF9kYXRlPzogc3RyaW5nO1xyXG4gICAgZW5kX2RhdGU/OiBzdHJpbmc7XHJcbiAgICBsaW1pdD86IG51bWJlcjtcclxuICB9KSA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGF1ZGl0TG9nc0FQSS5nZXRBdWRpdExvZ3MoZmlsdGVycyk7XHJcbiAgICAgIHNldExvZ3MoZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGF1ZGl0IGxvZ3M6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGF1ZGl0IGxvZ3MnKTtcclxuICAgICAgc2V0TG9ncyhbXSk7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbXSk7XHJcblxyXG4gIGNvbnN0IGNyZWF0ZUF1ZGl0TG9nID0gdXNlQ2FsbGJhY2soYXN5bmMgKGF1ZGl0RGF0YToge1xyXG4gICAgYWN0aW9uOiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZV90eXBlOiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZV9pZD86IHN0cmluZztcclxuICAgIGRldGFpbHM/OiBhbnk7XHJcbiAgfSkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgYXVkaXRMb2dzQVBJLmNyZWF0ZUF1ZGl0TG9nKGF1ZGl0RGF0YSk7XHJcbiAgICAgIC8vIFJlZnJlc2ggbG9ncyBhZnRlciBjcmVhdGluZyBuZXcgb25lXHJcbiAgICAgIGF3YWl0IGZldGNoQXVkaXRMb2dzKCk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBhdWRpdCBsb2c6JywgZXJyKTtcclxuICAgICAgdGhyb3cgZXJyO1xyXG4gICAgfVxyXG4gIH0sIFtmZXRjaEF1ZGl0TG9nc10pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgbG9ncyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGZldGNoQXVkaXRMb2dzLFxyXG4gICAgY3JlYXRlQXVkaXRMb2dcclxuICB9O1xyXG59O1xyXG5cclxuLy8gQ3VzdG9tIGhvb2sgZm9yIGNhdGVnb3JpZXNcclxuZXhwb3J0IGNvbnN0IHVzZUNhdGVnb3JpZXMgPSAoKSA9PiB7XHJcbiAgY29uc3QgW2NhdGVnb3JpZXMsIHNldENhdGVnb3JpZXNdID0gdXNlU3RhdGU8Q2F0ZWdvcnlbXT4oW10pO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IGZldGNoQWxsQ2F0ZWdvcmllcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2F0ZWdvcnlBUEkuZ2V0QWxsQ2F0ZWdvcmllcygpO1xyXG4gICAgICBzZXRDYXRlZ29yaWVzKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBjYXRlZ29yaWVzOicsIGVycik7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjYXRlZ29yaWVzJyk7XHJcbiAgICAgIHNldENhdGVnb3JpZXMoW10pO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2F0ZWdvcmllcyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGZldGNoQWxsQ2F0ZWdvcmllc1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBDdXN0b20gaG9vayBmb3IgaW5zdHJ1Y3RvcnNcclxuZXhwb3J0IGNvbnN0IHVzZUluc3RydWN0b3JzID0gKCkgPT4ge1xyXG4gIGNvbnN0IFtpbnN0cnVjdG9ycywgc2V0SW5zdHJ1Y3RvcnNdID0gdXNlU3RhdGU8SW5zdHJ1Y3RvcltdPihbXSk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgY29uc3QgZmV0Y2hBbGxJbnN0cnVjdG9ycyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgaW5zdHJ1Y3RvckFQSS5nZXRBbGxJbnN0cnVjdG9ycygpO1xyXG4gICAgICBzZXRJbnN0cnVjdG9ycyhkYXRhKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggaW5zdHJ1Y3RvcnM6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGluc3RydWN0b3JzJyk7XHJcbiAgICAgIHNldEluc3RydWN0b3JzKFtdKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGluc3RydWN0b3JzLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgZmV0Y2hBbGxJbnN0cnVjdG9yc1xyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIb29rIGZvciBtYW5hZ2luZyB1c2VyIHByb2dyZXNzXHJcbmV4cG9ydCBjb25zdCB1c2VVc2VyUHJvZ3Jlc3MgPSAodXNlcklkOiBzdHJpbmcpID0+IHtcclxuICBjb25zdCBbcHJvZ3Jlc3MsIHNldFByb2dyZXNzXSA9IHVzZVN0YXRlPFVzZXJQcm9ncmVzc1tdPihbXSk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IGZldGNoVXNlclByb2dyZXNzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcclxuXHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcHJvZ3Jlc3NBUEkuZ2V0QWxsVXNlclByb2dyZXNzKHVzZXJJZCk7XHJcbiAgICAgIHNldFByb2dyZXNzKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdXNlciBwcm9ncmVzcycpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyIHByb2dyZXNzOicsIGVycik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbdXNlcklkXSk7XHJcblxyXG4gIGNvbnN0IHVwZGF0ZVByb2dyZXNzID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvdXJzZUlkOiBzdHJpbmcsIHByb2dyZXNzRGF0YTogUGFydGlhbDxVc2VyUHJvZ3Jlc3M+KSA9PiB7XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBwcm9ncmVzc0FQSS51cGRhdGVQcm9ncmVzcyh1c2VySWQsIGNvdXJzZUlkLCBwcm9ncmVzc0RhdGEpO1xyXG4gICAgICBhd2FpdCBmZXRjaFVzZXJQcm9ncmVzcygpOyAvLyBSZWZyZXNoIGRhdGFcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBzZXRFcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBwcm9ncmVzcycpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBwcm9ncmVzczonLCBlcnIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW3VzZXJJZCwgZmV0Y2hVc2VyUHJvZ3Jlc3NdKTtcclxuXHJcbiAgY29uc3QgY3JlYXRlUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjayhhc3luYyAocHJvZ3Jlc3NEYXRhOiBQYXJ0aWFsPFVzZXJQcm9ncmVzcz4pID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IHByb2dyZXNzQVBJLmNyZWF0ZVByb2dyZXNzKHByb2dyZXNzRGF0YSk7XHJcbiAgICAgIGF3YWl0IGZldGNoVXNlclByb2dyZXNzKCk7IC8vIFJlZnJlc2ggZGF0YVxyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHByb2dyZXNzJyk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHByb2dyZXNzOicsIGVycik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbZmV0Y2hVc2VyUHJvZ3Jlc3NdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHByb2dyZXNzLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgZmV0Y2hVc2VyUHJvZ3Jlc3MsXHJcbiAgICB1cGRhdGVQcm9ncmVzcyxcclxuICAgIGNyZWF0ZVByb2dyZXNzLFxyXG4gIH07XHJcbn07XHJcblxyXG4vLyBIb29rIGZvciBtYW5hZ2luZyBjZXJ0aWZpY2F0ZXNcclxuZXhwb3J0IGNvbnN0IHVzZUNlcnRpZmljYXRlcyA9ICh1c2VySWQ6IHN0cmluZykgPT4ge1xyXG4gIGNvbnN0IFtjZXJ0aWZpY2F0ZXMsIHNldENlcnRpZmljYXRlc10gPSB1c2VTdGF0ZTxDZXJ0aWZpY2F0ZVtdPihbXSk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IGZldGNoVXNlckNlcnRpZmljYXRlcyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmICghdXNlcklkKSByZXR1cm47XHJcblxyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNlcnRpZmljYXRlQVBJLmdldFVzZXJDZXJ0aWZpY2F0ZXModXNlcklkKTtcclxuICAgICAgc2V0Q2VydGlmaWNhdGVzKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY2VydGlmaWNhdGVzJyk7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNlcnRpZmljYXRlczonLCBlcnIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW3VzZXJJZF0pO1xyXG5cclxuICBjb25zdCB2ZXJpZnlDZXJ0aWZpY2F0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jICh2ZXJpZmljYXRpb25Db2RlOiBzdHJpbmcpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjZXJ0aWZpY2F0ZUFQSS52ZXJpZnlDZXJ0aWZpY2F0ZSh2ZXJpZmljYXRpb25Db2RlKTtcclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byB2ZXJpZnkgY2VydGlmaWNhdGUnKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGNlcnRpZmljYXRlOicsIGVycik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgY2VydGlmaWNhdGVzLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgZmV0Y2hVc2VyQ2VydGlmaWNhdGVzLFxyXG4gICAgdmVyaWZ5Q2VydGlmaWNhdGUsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEhvb2sgZm9yIG1hbmFnaW5nIGFjaGlldmVtZW50c1xyXG5leHBvcnQgY29uc3QgdXNlQWNoaWV2ZW1lbnRzID0gKHVzZXJJZDogc3RyaW5nKSA9PiB7XHJcbiAgY29uc3QgW2FjaGlldmVtZW50cywgc2V0QWNoaWV2ZW1lbnRzXSA9IHVzZVN0YXRlPEFjaGlldmVtZW50W10+KFtdKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgY29uc3QgZmV0Y2hVc2VyQWNoaWV2ZW1lbnRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcclxuXHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgYWNoaWV2ZW1lbnRBUEkuZ2V0VXNlckFjaGlldmVtZW50cyh1c2VySWQpO1xyXG4gICAgICBzZXRBY2hpZXZlbWVudHMoZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBhY2hpZXZlbWVudHMnKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWNoaWV2ZW1lbnRzOicsIGVycik7XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgIH1cclxuICB9LCBbdXNlcklkXSk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBhY2hpZXZlbWVudHMsXHJcbiAgICBsb2FkaW5nLFxyXG4gICAgZXJyb3IsXHJcbiAgICBmZXRjaFVzZXJBY2hpZXZlbWVudHMsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEhvb2sgZm9yIG1hbmFnaW5nIHVzZXJzXHJcbmV4cG9ydCBjb25zdCB1c2VVc2VycyA9ICgpID0+IHtcclxuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7IC8vIENoYW5nZWQgdG8gYW55W10gYXMgVXNlciB0eXBlIGlzIHJlbW92ZWRcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgY29uc3QgZmV0Y2hBbGxVc2VycyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHVzZXJBUEkuZ2V0VXNlcnMoKTtcclxuICAgICAgICBzZXRVc2VycyhkYXRhKTtcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdXNlcnMnKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlcnM6JywgZXJyKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgZmV0Y2hVc2VyQnlJZCA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VySWQ6IHN0cmluZykgPT4ge1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdXNlckFQSS5nZXRVc2VyKHVzZXJJZCk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGZldGNoIHVzZXInKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlcjonLCBlcnIpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgY29uc3QgY3JlYXRlVXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyRGF0YTogUGFydGlhbDxhbnk+KSA9PiB7IC8vIENoYW5nZWQgdG8gYW55XHJcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xyXG4gICAgc2V0RXJyb3IobnVsbCk7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVzZXJBUEkuY3JlYXRlVXNlcih1c2VyRGF0YSk7XHJcbiAgICAgICAgYXdhaXQgZmV0Y2hBbGxVc2VycygpOyAvLyBSZWZyZXNoIGRhdGFcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdXNlcicpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyB1c2VyOicsIGVycik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW2ZldGNoQWxsVXNlcnNdKTtcclxuXHJcbiAgY29uc3QgdXBkYXRlVXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VySWQ6IHN0cmluZywgdXNlckRhdGE6IFBhcnRpYWw8YW55PikgPT4geyAvLyBDaGFuZ2VkIHRvIGFueVxyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHNldEVycm9yKG51bGwpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICBhd2FpdCB1c2VyQVBJLnVwZGF0ZVVzZXIodXNlcklkLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgYXdhaXQgZmV0Y2hBbGxVc2VycygpOyAvLyBSZWZyZXNoIGRhdGFcclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIHVzZXInKTtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgdXNlcjonLCBlcnIpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW2ZldGNoQWxsVXNlcnNdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHVzZXJzLFxyXG4gICAgbG9hZGluZyxcclxuICAgIGVycm9yLFxyXG4gICAgZmV0Y2hBbGxVc2VycyxcclxuICAgIGZldGNoVXNlckJ5SWQsXHJcbiAgICBjcmVhdGVVc2VyLFxyXG4gICAgdXBkYXRlVXNlcixcclxuICB9O1xyXG59O1xyXG5cclxuLy8gSG9vayBmb3IgcGxhdGZvcm0gYW5hbHl0aWNzXHJcbmV4cG9ydCBjb25zdCB1c2VBbmFseXRpY3MgPSAoKSA9PiB7XHJcbiAgY29uc3QgW3N0YXRzLCBzZXRTdGF0c10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpO1xyXG4gIGNvbnN0IFtkZXRhaWxlZFN0YXRzLCBzZXREZXRhaWxlZFN0YXRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XHJcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gIGNvbnN0IGZldGNoUGxhdGZvcm1TdGF0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIHNldExvYWRpbmcodHJ1ZSk7XHJcbiAgICBzZXRFcnJvcihudWxsKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OKIEZldGNoaW5nIHBsYXRmb3JtIHN0YXRzLi4uJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBhbmFseXRpY3NBUEkuZ2V0UGxhdGZvcm1TdGF0cygpO1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+TiiBQbGF0Zm9ybSBzdGF0cyByZWNlaXZlZDonLCBkYXRhKTtcclxuICAgICAgc2V0U3RhdHMoZGF0YSk7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBwbGF0Zm9ybSBzdGF0cycpO1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF0Zm9ybSBzdGF0czonLCBlcnIpO1xyXG4gICAgICAvLyBTZXQgZmFsbGJhY2sgZGF0YVxyXG4gICAgICBzZXRTdGF0cyh7XHJcbiAgICAgICAgdG90YWxVc2VyczogMCxcclxuICAgICAgICB0b3RhbENvdXJzZXM6IDAsXHJcbiAgICAgICAgdG90YWxMZXNzb25zOiAwLFxyXG4gICAgICAgIHRvdGFsQ2VydGlmaWNhdGVzOiAwLFxyXG4gICAgICAgIHRvdGFsSW5zdHJ1Y3RvcnM6IDAsXHJcbiAgICAgICAgY29tcGxldGVkQ291cnNlczogMCxcclxuICAgICAgICBhY3RpdmVTdHVkZW50czogMCxcclxuICAgICAgICB0b3RhbFhQOiAwXHJcbiAgICAgIH0pO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSwgW10pO1xyXG5cclxuICBjb25zdCBmZXRjaERldGFpbGVkQW5hbHl0aWNzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGFuYWx5dGljc0FQSS5nZXREZXRhaWxlZEFuYWx5dGljcygpO1xyXG4gICAgICBzZXREZXRhaWxlZFN0YXRzKGRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBkZXRhaWxlZCBhbmFseXRpY3M6JywgZXJyKTtcclxuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGRldGFpbGVkIGFuYWx5dGljcycpO1xyXG4gICAgfVxyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRzLFxyXG4gICAgZGV0YWlsZWRTdGF0cyxcclxuICAgIGxvYWRpbmcsXHJcbiAgICBlcnJvcixcclxuICAgIGZldGNoUGxhdGZvcm1TdGF0cyxcclxuICAgIGZldGNoRGV0YWlsZWRBbmFseXRpY3MsXHJcbiAgfTtcclxufTtcclxuXHJcbi8vIEV4YW1wbGUgdXNhZ2UgaW4gY29tcG9uZW50czpcclxuLypcclxuaW1wb3J0IHsgdXNlQ291cnNlcywgdXNlVXNlclByb2dyZXNzIH0gZnJvbSAnLi4vaG9va3MvdXNlRGF0YWJhc2UnO1xyXG5cclxuY29uc3QgSG9tZVBhZ2UgPSAoKSA9PiB7XHJcbiAgY29uc3QgeyBmZWF0dXJlZENvdXJzZXMsIGxvYWRpbmcsIGZldGNoRmVhdHVyZWRDb3Vyc2VzIH0gPSB1c2VDb3Vyc2VzKCk7XHJcbiAgY29uc3QgeyBwcm9ncmVzcywgZmV0Y2hVc2VyUHJvZ3Jlc3MgfSA9IHVzZVVzZXJQcm9ncmVzcyh1c2VySWQpO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgZmV0Y2hGZWF0dXJlZENvdXJzZXMoKTtcclxuICAgIGZldGNoVXNlclByb2dyZXNzKCk7XHJcbiAgfSwgW10pO1xyXG5cclxuICBpZiAobG9hZGluZykgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXY+XHJcbiAgICAgIHtmZWF0dXJlZENvdXJzZXMubWFwKGNvdXJzZSA9PiAoXHJcbiAgICAgICAgPENvdXJzZUNhcmQga2V5PXtjb3Vyc2UuaWR9IGNvdXJzZT17Y291cnNlfSAvPlxyXG4gICAgICApKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcbiovIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJjb3Vyc2VBUEkiLCJjYXRlZ29yeUFQSSIsImluc3RydWN0b3JBUEkiLCJwcm9ncmVzc0FQSSIsImNlcnRpZmljYXRlQVBJIiwiYWNoaWV2ZW1lbnRBUEkiLCJhbmFseXRpY3NBUEkiLCJ1c2VyQVBJIiwiYXVkaXRMb2dzQVBJIiwiZ2V0QWxsQ291cnNlcyIsImdldE1vY2tDb3Vyc2VzIiwiZ2V0RmVhdHVyZWRDb3Vyc2VzIiwiZ2V0TW9ja0ZlYXR1cmVkQ291cnNlcyIsInVzZUNvdXJzZXMiLCJjb3Vyc2VzIiwic2V0Q291cnNlcyIsImZlYXR1cmVkQ291cnNlcyIsInNldEZlYXR1cmVkQ291cnNlcyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImZldGNoQWxsQ291cnNlcyIsImRhdGEiLCJ0cmFuc2Zvcm1lZENvdXJzZXMiLCJtYXAiLCJjb3Vyc2UiLCJpZCIsInRpdGxlIiwiaW5zdHJ1Y3RvciIsImluc3RydWN0b3JfaWQiLCJuYW1lIiwiaW5zdHJ1Y3Rvcl9uYW1lIiwiaW5zdHJ1Y3Rvcl90aXRsZSIsImltYWdlIiwiaW5zdHJ1Y3Rvcl9pbWFnZSIsImJpbyIsImluc3RydWN0b3JfYmlvIiwiZW1haWwiLCJpbnN0cnVjdG9yX2VtYWlsIiwiZXhwZXJ0aXNlIiwiaW5zdHJ1Y3Rvcl9leHBlcnRpc2UiLCJKU09OIiwicGFyc2UiLCJleHBlcmllbmNlIiwiaW5zdHJ1Y3Rvcl9leHBlcmllbmNlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsImluc3RydWN0b3JfY3JlYXRlZF9hdCIsIm5vdyIsImluc3RydWN0b3JJZCIsImNhdGVnb3J5IiwiY2F0ZWdvcnlfbmFtZSIsInRodW1ibmFpbCIsImJhbm5lciIsInZpZGVvVXJsIiwidmlkZW9fdXJsIiwiZGVzY3JpcHRpb24iLCJsZXNzb25zIiwiZmVhdHVyZWQiLCJ0b3RhbFhQIiwidG90YWxfeHAiLCJjb21pbmdTb29uIiwiY29taW5nX3Nvb24iLCJyZWxlYXNlRGF0ZSIsInJlbGVhc2VfZGF0ZSIsImVyciIsImNvbnNvbGUiLCJtb2NrQ291cnNlcyIsImZldGNoRmVhdHVyZWRDb3Vyc2VzIiwibW9ja0ZlYXR1cmVkQ291cnNlcyIsInVzZUF1ZGl0TG9ncyIsImxvZ3MiLCJzZXRMb2dzIiwiZmV0Y2hBdWRpdExvZ3MiLCJmaWx0ZXJzIiwiZ2V0QXVkaXRMb2dzIiwiY3JlYXRlQXVkaXRMb2ciLCJhdWRpdERhdGEiLCJ1c2VDYXRlZ29yaWVzIiwiY2F0ZWdvcmllcyIsInNldENhdGVnb3JpZXMiLCJmZXRjaEFsbENhdGVnb3JpZXMiLCJnZXRBbGxDYXRlZ29yaWVzIiwidXNlSW5zdHJ1Y3RvcnMiLCJpbnN0cnVjdG9ycyIsInNldEluc3RydWN0b3JzIiwiZmV0Y2hBbGxJbnN0cnVjdG9ycyIsImdldEFsbEluc3RydWN0b3JzIiwidXNlVXNlclByb2dyZXNzIiwidXNlcklkIiwicHJvZ3Jlc3MiLCJzZXRQcm9ncmVzcyIsImZldGNoVXNlclByb2dyZXNzIiwiZ2V0QWxsVXNlclByb2dyZXNzIiwidXBkYXRlUHJvZ3Jlc3MiLCJjb3Vyc2VJZCIsInByb2dyZXNzRGF0YSIsImNyZWF0ZVByb2dyZXNzIiwidXNlQ2VydGlmaWNhdGVzIiwiY2VydGlmaWNhdGVzIiwic2V0Q2VydGlmaWNhdGVzIiwiZmV0Y2hVc2VyQ2VydGlmaWNhdGVzIiwiZ2V0VXNlckNlcnRpZmljYXRlcyIsInZlcmlmeUNlcnRpZmljYXRlIiwidmVyaWZpY2F0aW9uQ29kZSIsInVzZUFjaGlldmVtZW50cyIsImFjaGlldmVtZW50cyIsInNldEFjaGlldmVtZW50cyIsImZldGNoVXNlckFjaGlldmVtZW50cyIsImdldFVzZXJBY2hpZXZlbWVudHMiLCJ1c2VVc2VycyIsInVzZXJzIiwic2V0VXNlcnMiLCJmZXRjaEFsbFVzZXJzIiwiZ2V0VXNlcnMiLCJmZXRjaFVzZXJCeUlkIiwiZ2V0VXNlciIsImNyZWF0ZVVzZXIiLCJ1c2VyRGF0YSIsInJlc3VsdCIsInVwZGF0ZVVzZXIiLCJ1c2VBbmFseXRpY3MiLCJzdGF0cyIsInNldFN0YXRzIiwiZGV0YWlsZWRTdGF0cyIsInNldERldGFpbGVkU3RhdHMiLCJmZXRjaFBsYXRmb3JtU3RhdHMiLCJsb2ciLCJnZXRQbGF0Zm9ybVN0YXRzIiwidG90YWxVc2VycyIsInRvdGFsQ291cnNlcyIsInRvdGFsTGVzc29ucyIsInRvdGFsQ2VydGlmaWNhdGVzIiwidG90YWxJbnN0cnVjdG9ycyIsImNvbXBsZXRlZENvdXJzZXMiLCJhY3RpdmVTdHVkZW50cyIsImZldGNoRGV0YWlsZWRBbmFseXRpY3MiLCJnZXREZXRhaWxlZEFuYWx5dGljcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/hooks/useDatabase.ts\n"));

/***/ })

});