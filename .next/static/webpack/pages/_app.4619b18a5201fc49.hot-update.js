"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   achievementAPI: function() { return /* binding */ achievementAPI; },\n/* harmony export */   analyticsAPI: function() { return /* binding */ analyticsAPI; },\n/* harmony export */   api: function() { return /* binding */ api; },\n/* harmony export */   auditLogsAPI: function() { return /* binding */ auditLogsAPI; },\n/* harmony export */   categoryAPI: function() { return /* binding */ categoryAPI; },\n/* harmony export */   certificateAPI: function() { return /* binding */ certificateAPI; },\n/* harmony export */   courseAPI: function() { return /* binding */ courseAPI; },\n/* harmony export */   instructorAPI: function() { return /* binding */ instructorAPI; },\n/* harmony export */   progressAPI: function() { return /* binding */ progressAPI; },\n/* harmony export */   userAPI: function() { return /* binding */ userAPI; }\n/* harmony export */ });\n/* harmony import */ var _mysql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mysql */ \"./src/lib/mysql.ts\");\n// API Service for Database Operations\n// This service handles all HTTP requests to your backend server\n\n// Generic API request function with authentication\nconst apiRequest = async function(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const url = \"\".concat(_mysql__WEBPACK_IMPORTED_MODULE_0__.API_BASE_URL).concat(endpoint);\n    // Check if we're on the client side before accessing localStorage\n    const token =  true ? localStorage.getItem(\"forward_africa_token\") : 0;\n    const defaultOptions = {\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...token && {\n                \"Authorization\": \"Bearer \".concat(token)\n            },\n            ...options.headers\n        },\n        ...options\n    };\n    try {\n        const response = await fetch(url, defaultOptions);\n        if (response.status === 401) {\n            // Clear auth data and redirect to login (only on client side)\n            if (true) {\n                localStorage.removeItem(\"forward_africa_token\");\n                localStorage.removeItem(\"forward_africa_user\");\n                window.location.href = \"/login\";\n            }\n            throw new Error(\"Authentication required\");\n        }\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(errorData.error || \"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error(\"API request failed:\", error);\n        throw error;\n    }\n};\n// User API\nconst userAPI = {\n    // Get all users\n    getUsers: ()=>apiRequest(\"/users\"),\n    // Get user by ID\n    getUser: (userId)=>apiRequest(\"/users/\".concat(userId)),\n    // Get user by email\n    getUserByEmail: (email)=>apiRequest(\"/users/email/\".concat(email)),\n    // Create new user\n    createUser: (userData)=>apiRequest(\"/users\", {\n            method: \"POST\",\n            body: JSON.stringify(userData)\n        }),\n    // Update user\n    updateUser: (userId, userData)=>apiRequest(\"/users/\".concat(userId), {\n            method: \"PUT\",\n            body: JSON.stringify(userData)\n        }),\n    // Delete user\n    deleteUser: (userId)=>apiRequest(\"/users/\".concat(userId), {\n            method: \"DELETE\"\n        })\n};\n// Course API\nconst courseAPI = {\n    // Get all courses\n    getAllCourses: ()=>apiRequest(\"/courses\"),\n    // Get course by ID\n    getCourse: (courseId)=>apiRequest(\"/courses/\".concat(courseId)),\n    // Get featured courses\n    getFeaturedCourses: ()=>apiRequest(\"/courses/featured\"),\n    // Get courses by category\n    getCoursesByCategory: (categoryId)=>apiRequest(\"/courses/category/\".concat(categoryId)),\n    // Create new course\n    createCourse: (courseData)=>apiRequest(\"/courses\", {\n            method: \"POST\",\n            body: JSON.stringify(courseData)\n        }),\n    // Update course\n    updateCourse: (courseId, courseData)=>apiRequest(\"/courses/\".concat(courseId), {\n            method: \"PUT\",\n            body: JSON.stringify(courseData)\n        }),\n    // Delete course\n    deleteCourse: (courseId)=>apiRequest(\"/courses/\".concat(courseId), {\n            method: \"DELETE\"\n        })\n};\n// Category API\nconst categoryAPI = {\n    // Get all categories\n    getAllCategories: ()=>apiRequest(\"/categories\"),\n    // Get category by ID\n    getCategory: (categoryId)=>apiRequest(\"/categories/\".concat(categoryId)),\n    // Create new category\n    createCategory: (categoryData)=>apiRequest(\"/categories\", {\n            method: \"POST\",\n            body: JSON.stringify(categoryData)\n        }),\n    // Update category\n    updateCategory: (categoryId, categoryData)=>apiRequest(\"/categories/\".concat(categoryId), {\n            method: \"PUT\",\n            body: JSON.stringify(categoryData)\n        }),\n    // Delete category\n    deleteCategory: (categoryId)=>apiRequest(\"/categories/\".concat(categoryId), {\n            method: \"DELETE\"\n        })\n};\n// Instructor API\nconst instructorAPI = {\n    // Get all instructors\n    getAllInstructors: ()=>apiRequest(\"/instructors\"),\n    // Get instructor by ID\n    getInstructor: (instructorId)=>apiRequest(\"/instructors/\".concat(instructorId)),\n    // Get instructor courses\n    getInstructorCourses: (instructorId)=>apiRequest(\"/instructors/\".concat(instructorId, \"/courses\")),\n    // Create new instructor\n    createInstructor: (instructorData)=>apiRequest(\"/instructors\", {\n            method: \"POST\",\n            body: JSON.stringify(instructorData)\n        }),\n    // Update instructor\n    updateInstructor: (instructorId, instructorData)=>apiRequest(\"/instructors/\".concat(instructorId), {\n            method: \"PUT\",\n            body: JSON.stringify(instructorData)\n        }),\n    // Delete instructor\n    deleteInstructor: (instructorId)=>apiRequest(\"/instructors/\".concat(instructorId), {\n            method: \"DELETE\"\n        })\n};\n// User Progress API\nconst progressAPI = {\n    // Get user progress for a course\n    getUserProgress: (userId, courseId)=>apiRequest(\"/progress/\".concat(userId, \"/\").concat(courseId)),\n    // Get all user progress\n    getAllUserProgress: (userId)=>apiRequest(\"/progress/\".concat(userId)),\n    // Update user progress\n    updateProgress: (userId, courseId, progressData)=>apiRequest(\"/progress/\".concat(userId, \"/\").concat(courseId), {\n            method: \"PUT\",\n            body: JSON.stringify(progressData)\n        }),\n    // Create user progress\n    createProgress: (progressData)=>apiRequest(\"/progress\", {\n            method: \"POST\",\n            body: JSON.stringify(progressData)\n        })\n};\n// Certificate API\nconst certificateAPI = {\n    // Get user certificates\n    getUserCertificates: (userId)=>apiRequest(\"/certificates/\".concat(userId)),\n    // Get certificate by ID\n    getCertificate: (certificateId)=>apiRequest(\"/certificates/id/\".concat(certificateId)),\n    // Verify certificate\n    verifyCertificate: (verificationCode)=>apiRequest(\"/certificates/verify/\".concat(verificationCode)),\n    // Create certificate\n    createCertificate: (certificateData)=>apiRequest(\"/certificates\", {\n            method: \"POST\",\n            body: JSON.stringify(certificateData)\n        })\n};\n// Achievement API\nconst achievementAPI = {\n    // Get user achievements\n    getUserAchievements: (userId)=>apiRequest(\"/achievements/\".concat(userId)),\n    // Create achievement\n    createAchievement: (achievementData)=>apiRequest(\"/achievements\", {\n            method: \"POST\",\n            body: JSON.stringify(achievementData)\n        }),\n    // Update achievement progress\n    updateAchievementProgress: (achievementId, progress)=>apiRequest(\"/achievements/\".concat(achievementId, \"/progress\"), {\n            method: \"PUT\",\n            body: JSON.stringify({\n                progress\n            })\n        })\n};\n// Analytics API\nconst analyticsAPI = {\n    // Get platform statistics\n    getPlatformStats: ()=>apiRequest(\"/analytics/platform\"),\n    // Get detailed analytics\n    getDetailedAnalytics: ()=>apiRequest(\"/analytics/detailed\"),\n    // Get user statistics\n    getUserStats: (userId)=>apiRequest(\"/analytics/user/\".concat(userId)),\n    // Get course statistics\n    getCourseStats: (courseId)=>apiRequest(\"/analytics/course/\".concat(courseId))\n};\n// Audit Logs API\nconst auditLogsAPI = {\n    // Get all audit logs with optional filtering\n    getAuditLogs: (filters)=>{\n        const params = new URLSearchParams();\n        if (filters) {\n            Object.entries(filters).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined) {\n                    params.append(key, value.toString());\n                }\n            });\n        }\n        return apiRequest(\"/audit-logs?\".concat(params.toString()));\n    },\n    // Create audit log\n    createAuditLog: (auditData)=>apiRequest(\"/audit-logs\", {\n            method: \"POST\",\n            body: JSON.stringify(auditData)\n        })\n};\n// Export all APIs\nconst api = {\n    user: userAPI,\n    course: courseAPI,\n    category: categoryAPI,\n    instructor: instructorAPI,\n    progress: progressAPI,\n    certificate: certificateAPI,\n    achievement: achievementAPI,\n    analytics: analyticsAPI,\n    auditLogs: auditLogsAPI\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bkJDLGdCQUFnQixDQUFDQyxZQU1mekcsV0FBVyxlQUFlO1lBQ3hCZ0MsUUFBUTtZQUNSQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNzRTtRQUN2QjtBQUNKLEVBQUU7QUFFRixrQkFBa0I7QUFDWCxNQUFNQyxNQUFNO0lBQ2pCQyxNQUFNbkY7SUFDTm9GLFFBQVF0RTtJQUNSdUUsVUFBVTVEO0lBQ1Y2RCxZQUFZdEQ7SUFDWjZCLFVBQVVwQjtJQUNWOEMsYUFBYXhDO0lBQ2J5QyxhQUFhakM7SUFDYmtDLFdBQVczQjtJQUNYNEIsV0FBV3ZCO0FBQ2IsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2FwaS50cz8yZmFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFQSSBTZXJ2aWNlIGZvciBEYXRhYmFzZSBPcGVyYXRpb25zXHJcbi8vIFRoaXMgc2VydmljZSBoYW5kbGVzIGFsbCBIVFRQIHJlcXVlc3RzIHRvIHlvdXIgYmFja2VuZCBzZXJ2ZXJcclxuXHJcbmltcG9ydCB7IEFQSV9CQVNFX1VSTCB9IGZyb20gJy4vbXlzcWwnO1xyXG5pbXBvcnQgeyBDb3Vyc2UsIENhdGVnb3J5LCBJbnN0cnVjdG9yLCBVc2VyLCBVc2VyUHJvZ3Jlc3MsIENlcnRpZmljYXRlLCBBY2hpZXZlbWVudCB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbi8vIEdlbmVyaWMgQVBJIHJlcXVlc3QgZnVuY3Rpb24gd2l0aCBhdXRoZW50aWNhdGlvblxyXG5jb25zdCBhcGlSZXF1ZXN0ID0gYXN5bmMgKGVuZHBvaW50OiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30pID0+IHtcclxuICBjb25zdCB1cmwgPSBgJHtBUElfQkFTRV9VUkx9JHtlbmRwb2ludH1gO1xyXG5cclxuICAvLyBDaGVjayBpZiB3ZSdyZSBvbiB0aGUgY2xpZW50IHNpZGUgYmVmb3JlIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2VcclxuICBjb25zdCB0b2tlbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2ZvcndhcmRfYWZyaWNhX3Rva2VuJykgOiBudWxsO1xyXG5cclxuICBjb25zdCBkZWZhdWx0T3B0aW9uczogUmVxdWVzdEluaXQgPSB7XHJcbiAgICBoZWFkZXJzOiB7XHJcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIC4uLih0b2tlbiAmJiB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWAgfSksXHJcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcclxuICAgIH0sXHJcbiAgICAuLi5vcHRpb25zLFxyXG4gIH07XHJcblxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwgZGVmYXVsdE9wdGlvbnMpO1xyXG5cclxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xyXG4gICAgICAvLyBDbGVhciBhdXRoIGRhdGEgYW5kIHJlZGlyZWN0IHRvIGxvZ2luIChvbmx5IG9uIGNsaWVudCBzaWRlKVxyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9yd2FyZF9hZnJpY2FfdG9rZW4nKTtcclxuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZm9yd2FyZF9hZnJpY2FfdXNlcicpO1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy9sb2dpbic7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignQVBJIHJlcXVlc3QgZmFpbGVkOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufTtcclxuXHJcbi8vIFVzZXIgQVBJXHJcbmV4cG9ydCBjb25zdCB1c2VyQVBJID0ge1xyXG4gIC8vIEdldCBhbGwgdXNlcnNcclxuICBnZXRVc2VyczogKCkgPT4gYXBpUmVxdWVzdCgnL3VzZXJzJyksXHJcblxyXG4gIC8vIEdldCB1c2VyIGJ5IElEXHJcbiAgZ2V0VXNlcjogKHVzZXJJZDogc3RyaW5nKSA9PiBhcGlSZXF1ZXN0KGAvdXNlcnMvJHt1c2VySWR9YCksXHJcblxyXG4gIC8vIEdldCB1c2VyIGJ5IGVtYWlsXHJcbiAgZ2V0VXNlckJ5RW1haWw6IChlbWFpbDogc3RyaW5nKSA9PiBhcGlSZXF1ZXN0KGAvdXNlcnMvZW1haWwvJHtlbWFpbH1gKSxcclxuXHJcbiAgLy8gQ3JlYXRlIG5ldyB1c2VyXHJcbiAgY3JlYXRlVXNlcjogKHVzZXJEYXRhOiBQYXJ0aWFsPFVzZXI+KSA9PlxyXG4gICAgYXBpUmVxdWVzdCgnL3VzZXJzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXNlckRhdGEpLFxyXG4gICAgfSksXHJcblxyXG4gIC8vIFVwZGF0ZSB1c2VyXHJcbiAgdXBkYXRlVXNlcjogKHVzZXJJZDogc3RyaW5nLCB1c2VyRGF0YTogUGFydGlhbDxVc2VyPikgPT5cclxuICAgIGFwaVJlcXVlc3QoYC91c2Vycy8ke3VzZXJJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSxcclxuICAgIH0pLFxyXG5cclxuICAvLyBEZWxldGUgdXNlclxyXG4gIGRlbGV0ZVVzZXI6ICh1c2VySWQ6IHN0cmluZykgPT5cclxuICAgIGFwaVJlcXVlc3QoYC91c2Vycy8ke3VzZXJJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICB9KSxcclxufTtcclxuXHJcbi8vIENvdXJzZSBBUElcclxuZXhwb3J0IGNvbnN0IGNvdXJzZUFQSSA9IHtcclxuICAvLyBHZXQgYWxsIGNvdXJzZXNcclxuICBnZXRBbGxDb3Vyc2VzOiAoKSA9PiBhcGlSZXF1ZXN0KCcvY291cnNlcycpLFxyXG5cclxuICAvLyBHZXQgY291cnNlIGJ5IElEXHJcbiAgZ2V0Q291cnNlOiAoY291cnNlSWQ6IHN0cmluZykgPT4gYXBpUmVxdWVzdChgL2NvdXJzZXMvJHtjb3Vyc2VJZH1gKSxcclxuXHJcbiAgLy8gR2V0IGZlYXR1cmVkIGNvdXJzZXNcclxuICBnZXRGZWF0dXJlZENvdXJzZXM6ICgpID0+IGFwaVJlcXVlc3QoJy9jb3Vyc2VzL2ZlYXR1cmVkJyksXHJcblxyXG4gIC8vIEdldCBjb3Vyc2VzIGJ5IGNhdGVnb3J5XHJcbiAgZ2V0Q291cnNlc0J5Q2F0ZWdvcnk6IChjYXRlZ29yeUlkOiBzdHJpbmcpID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvY291cnNlcy9jYXRlZ29yeS8ke2NhdGVnb3J5SWR9YCksXHJcblxyXG4gIC8vIENyZWF0ZSBuZXcgY291cnNlXHJcbiAgY3JlYXRlQ291cnNlOiAoY291cnNlRGF0YTogUGFydGlhbDxDb3Vyc2U+KSA9PlxyXG4gICAgYXBpUmVxdWVzdCgnL2NvdXJzZXMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjb3Vyc2VEYXRhKSxcclxuICAgIH0pLFxyXG5cclxuICAvLyBVcGRhdGUgY291cnNlXHJcbiAgdXBkYXRlQ291cnNlOiAoY291cnNlSWQ6IHN0cmluZywgY291cnNlRGF0YTogUGFydGlhbDxDb3Vyc2U+KSA9PlxyXG4gICAgYXBpUmVxdWVzdChgL2NvdXJzZXMvJHtjb3Vyc2VJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNvdXJzZURhdGEpLFxyXG4gICAgfSksXHJcblxyXG4gIC8vIERlbGV0ZSBjb3Vyc2VcclxuICBkZWxldGVDb3Vyc2U6IChjb3Vyc2VJZDogc3RyaW5nKSA9PlxyXG4gICAgYXBpUmVxdWVzdChgL2NvdXJzZXMvJHtjb3Vyc2VJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICB9KSxcclxufTtcclxuXHJcbi8vIENhdGVnb3J5IEFQSVxyXG5leHBvcnQgY29uc3QgY2F0ZWdvcnlBUEkgPSB7XHJcbiAgLy8gR2V0IGFsbCBjYXRlZ29yaWVzXHJcbiAgZ2V0QWxsQ2F0ZWdvcmllczogKCkgPT4gYXBpUmVxdWVzdCgnL2NhdGVnb3JpZXMnKSxcclxuXHJcbiAgLy8gR2V0IGNhdGVnb3J5IGJ5IElEXHJcbiAgZ2V0Q2F0ZWdvcnk6IChjYXRlZ29yeUlkOiBzdHJpbmcpID0+IGFwaVJlcXVlc3QoYC9jYXRlZ29yaWVzLyR7Y2F0ZWdvcnlJZH1gKSxcclxuXHJcbiAgLy8gQ3JlYXRlIG5ldyBjYXRlZ29yeVxyXG4gIGNyZWF0ZUNhdGVnb3J5OiAoY2F0ZWdvcnlEYXRhOiBQYXJ0aWFsPENhdGVnb3J5PikgPT5cclxuICAgIGFwaVJlcXVlc3QoJy9jYXRlZ29yaWVzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2F0ZWdvcnlEYXRhKSxcclxuICAgIH0pLFxyXG5cclxuICAvLyBVcGRhdGUgY2F0ZWdvcnlcclxuICB1cGRhdGVDYXRlZ29yeTogKGNhdGVnb3J5SWQ6IHN0cmluZywgY2F0ZWdvcnlEYXRhOiBQYXJ0aWFsPENhdGVnb3J5PikgPT5cclxuICAgIGFwaVJlcXVlc3QoYC9jYXRlZ29yaWVzLyR7Y2F0ZWdvcnlJZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNhdGVnb3J5RGF0YSksXHJcbiAgICB9KSxcclxuXHJcbiAgLy8gRGVsZXRlIGNhdGVnb3J5XHJcbiAgZGVsZXRlQ2F0ZWdvcnk6IChjYXRlZ29yeUlkOiBzdHJpbmcpID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvY2F0ZWdvcmllcy8ke2NhdGVnb3J5SWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgfSksXHJcbn07XHJcblxyXG4vLyBJbnN0cnVjdG9yIEFQSVxyXG5leHBvcnQgY29uc3QgaW5zdHJ1Y3RvckFQSSA9IHtcclxuICAvLyBHZXQgYWxsIGluc3RydWN0b3JzXHJcbiAgZ2V0QWxsSW5zdHJ1Y3RvcnM6ICgpID0+IGFwaVJlcXVlc3QoJy9pbnN0cnVjdG9ycycpLFxyXG5cclxuICAvLyBHZXQgaW5zdHJ1Y3RvciBieSBJRFxyXG4gIGdldEluc3RydWN0b3I6IChpbnN0cnVjdG9ySWQ6IHN0cmluZykgPT4gYXBpUmVxdWVzdChgL2luc3RydWN0b3JzLyR7aW5zdHJ1Y3RvcklkfWApLFxyXG5cclxuICAvLyBHZXQgaW5zdHJ1Y3RvciBjb3Vyc2VzXHJcbiAgZ2V0SW5zdHJ1Y3RvckNvdXJzZXM6IChpbnN0cnVjdG9ySWQ6IHN0cmluZykgPT4gYXBpUmVxdWVzdChgL2luc3RydWN0b3JzLyR7aW5zdHJ1Y3RvcklkfS9jb3Vyc2VzYCksXHJcblxyXG4gIC8vIENyZWF0ZSBuZXcgaW5zdHJ1Y3RvclxyXG4gIGNyZWF0ZUluc3RydWN0b3I6IChpbnN0cnVjdG9yRGF0YTogUGFydGlhbDxJbnN0cnVjdG9yPikgPT5cclxuICAgIGFwaVJlcXVlc3QoJy9pbnN0cnVjdG9ycycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGluc3RydWN0b3JEYXRhKSxcclxuICAgIH0pLFxyXG5cclxuICAvLyBVcGRhdGUgaW5zdHJ1Y3RvclxyXG4gIHVwZGF0ZUluc3RydWN0b3I6IChpbnN0cnVjdG9ySWQ6IHN0cmluZywgaW5zdHJ1Y3RvckRhdGE6IFBhcnRpYWw8SW5zdHJ1Y3Rvcj4pID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvaW5zdHJ1Y3RvcnMvJHtpbnN0cnVjdG9ySWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnN0cnVjdG9yRGF0YSksXHJcbiAgICB9KSxcclxuXHJcbiAgLy8gRGVsZXRlIGluc3RydWN0b3JcclxuICBkZWxldGVJbnN0cnVjdG9yOiAoaW5zdHJ1Y3RvcklkOiBzdHJpbmcpID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvaW5zdHJ1Y3RvcnMvJHtpbnN0cnVjdG9ySWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxyXG4gICAgfSksXHJcbn07XHJcblxyXG4vLyBVc2VyIFByb2dyZXNzIEFQSVxyXG5leHBvcnQgY29uc3QgcHJvZ3Jlc3NBUEkgPSB7XHJcbiAgLy8gR2V0IHVzZXIgcHJvZ3Jlc3MgZm9yIGEgY291cnNlXHJcbiAgZ2V0VXNlclByb2dyZXNzOiAodXNlcklkOiBzdHJpbmcsIGNvdXJzZUlkOiBzdHJpbmcpID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvcHJvZ3Jlc3MvJHt1c2VySWR9LyR7Y291cnNlSWR9YCksXHJcblxyXG4gIC8vIEdldCBhbGwgdXNlciBwcm9ncmVzc1xyXG4gIGdldEFsbFVzZXJQcm9ncmVzczogKHVzZXJJZDogc3RyaW5nKSA9PiBhcGlSZXF1ZXN0KGAvcHJvZ3Jlc3MvJHt1c2VySWR9YCksXHJcblxyXG4gIC8vIFVwZGF0ZSB1c2VyIHByb2dyZXNzXHJcbiAgdXBkYXRlUHJvZ3Jlc3M6ICh1c2VySWQ6IHN0cmluZywgY291cnNlSWQ6IHN0cmluZywgcHJvZ3Jlc3NEYXRhOiBQYXJ0aWFsPFVzZXJQcm9ncmVzcz4pID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvcHJvZ3Jlc3MvJHt1c2VySWR9LyR7Y291cnNlSWR9YCwge1xyXG4gICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0RhdGEpLFxyXG4gICAgfSksXHJcblxyXG4gIC8vIENyZWF0ZSB1c2VyIHByb2dyZXNzXHJcbiAgY3JlYXRlUHJvZ3Jlc3M6IChwcm9ncmVzc0RhdGE6IFBhcnRpYWw8VXNlclByb2dyZXNzPikgPT5cclxuICAgIGFwaVJlcXVlc3QoJy9wcm9ncmVzcycsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByb2dyZXNzRGF0YSksXHJcbiAgICB9KSxcclxufTtcclxuXHJcbi8vIENlcnRpZmljYXRlIEFQSVxyXG5leHBvcnQgY29uc3QgY2VydGlmaWNhdGVBUEkgPSB7XHJcbiAgLy8gR2V0IHVzZXIgY2VydGlmaWNhdGVzXHJcbiAgZ2V0VXNlckNlcnRpZmljYXRlczogKHVzZXJJZDogc3RyaW5nKSA9PiBhcGlSZXF1ZXN0KGAvY2VydGlmaWNhdGVzLyR7dXNlcklkfWApLFxyXG5cclxuICAvLyBHZXQgY2VydGlmaWNhdGUgYnkgSURcclxuICBnZXRDZXJ0aWZpY2F0ZTogKGNlcnRpZmljYXRlSWQ6IHN0cmluZykgPT4gYXBpUmVxdWVzdChgL2NlcnRpZmljYXRlcy9pZC8ke2NlcnRpZmljYXRlSWR9YCksXHJcblxyXG4gIC8vIFZlcmlmeSBjZXJ0aWZpY2F0ZVxyXG4gIHZlcmlmeUNlcnRpZmljYXRlOiAodmVyaWZpY2F0aW9uQ29kZTogc3RyaW5nKSA9PlxyXG4gICAgYXBpUmVxdWVzdChgL2NlcnRpZmljYXRlcy92ZXJpZnkvJHt2ZXJpZmljYXRpb25Db2RlfWApLFxyXG5cclxuICAvLyBDcmVhdGUgY2VydGlmaWNhdGVcclxuICBjcmVhdGVDZXJ0aWZpY2F0ZTogKGNlcnRpZmljYXRlRGF0YTogUGFydGlhbDxDZXJ0aWZpY2F0ZT4pID0+XHJcbiAgICBhcGlSZXF1ZXN0KCcvY2VydGlmaWNhdGVzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2VydGlmaWNhdGVEYXRhKSxcclxuICAgIH0pLFxyXG59O1xyXG5cclxuLy8gQWNoaWV2ZW1lbnQgQVBJXHJcbmV4cG9ydCBjb25zdCBhY2hpZXZlbWVudEFQSSA9IHtcclxuICAvLyBHZXQgdXNlciBhY2hpZXZlbWVudHNcclxuICBnZXRVc2VyQWNoaWV2ZW1lbnRzOiAodXNlcklkOiBzdHJpbmcpID0+IGFwaVJlcXVlc3QoYC9hY2hpZXZlbWVudHMvJHt1c2VySWR9YCksXHJcblxyXG4gIC8vIENyZWF0ZSBhY2hpZXZlbWVudFxyXG4gIGNyZWF0ZUFjaGlldmVtZW50OiAoYWNoaWV2ZW1lbnREYXRhOiBQYXJ0aWFsPEFjaGlldmVtZW50PikgPT5cclxuICAgIGFwaVJlcXVlc3QoJy9hY2hpZXZlbWVudHMnLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShhY2hpZXZlbWVudERhdGEpLFxyXG4gICAgfSksXHJcblxyXG4gIC8vIFVwZGF0ZSBhY2hpZXZlbWVudCBwcm9ncmVzc1xyXG4gIHVwZGF0ZUFjaGlldmVtZW50UHJvZ3Jlc3M6IChhY2hpZXZlbWVudElkOiBzdHJpbmcsIHByb2dyZXNzOiBudW1iZXIpID0+XHJcbiAgICBhcGlSZXF1ZXN0KGAvYWNoaWV2ZW1lbnRzLyR7YWNoaWV2ZW1lbnRJZH0vcHJvZ3Jlc3NgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvZ3Jlc3MgfSksXHJcbiAgICB9KSxcclxufTtcclxuXHJcbi8vIEFuYWx5dGljcyBBUElcclxuZXhwb3J0IGNvbnN0IGFuYWx5dGljc0FQSSA9IHtcclxuICAvLyBHZXQgcGxhdGZvcm0gc3RhdGlzdGljc1xyXG4gIGdldFBsYXRmb3JtU3RhdHM6ICgpID0+IGFwaVJlcXVlc3QoJy9hbmFseXRpY3MvcGxhdGZvcm0nKSxcclxuXHJcbiAgLy8gR2V0IGRldGFpbGVkIGFuYWx5dGljc1xyXG4gIGdldERldGFpbGVkQW5hbHl0aWNzOiAoKSA9PiBhcGlSZXF1ZXN0KCcvYW5hbHl0aWNzL2RldGFpbGVkJyksXHJcblxyXG4gIC8vIEdldCB1c2VyIHN0YXRpc3RpY3NcclxuICBnZXRVc2VyU3RhdHM6ICh1c2VySWQ6IHN0cmluZykgPT4gYXBpUmVxdWVzdChgL2FuYWx5dGljcy91c2VyLyR7dXNlcklkfWApLFxyXG5cclxuICAvLyBHZXQgY291cnNlIHN0YXRpc3RpY3NcclxuICBnZXRDb3Vyc2VTdGF0czogKGNvdXJzZUlkOiBzdHJpbmcpID0+IGFwaVJlcXVlc3QoYC9hbmFseXRpY3MvY291cnNlLyR7Y291cnNlSWR9YCksXHJcbn07XHJcblxyXG4vLyBBdWRpdCBMb2dzIEFQSVxyXG5leHBvcnQgY29uc3QgYXVkaXRMb2dzQVBJID0ge1xyXG4gIC8vIEdldCBhbGwgYXVkaXQgbG9ncyB3aXRoIG9wdGlvbmFsIGZpbHRlcmluZ1xyXG4gIGdldEF1ZGl0TG9nczogKGZpbHRlcnM/OiB7XHJcbiAgICBhY3Rpb24/OiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZV90eXBlPzogc3RyaW5nO1xyXG4gICAgdXNlcl9pZD86IHN0cmluZztcclxuICAgIHN0YXJ0X2RhdGU/OiBzdHJpbmc7XHJcbiAgICBlbmRfZGF0ZT86IHN0cmluZztcclxuICAgIGxpbWl0PzogbnVtYmVyO1xyXG4gIH0pID0+IHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgIGlmIChmaWx0ZXJzKSB7XHJcbiAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcGlSZXF1ZXN0KGAvYXVkaXQtbG9ncz8ke3BhcmFtcy50b1N0cmluZygpfWApO1xyXG4gIH0sXHJcblxyXG4gIC8vIENyZWF0ZSBhdWRpdCBsb2dcclxuICBjcmVhdGVBdWRpdExvZzogKGF1ZGl0RGF0YToge1xyXG4gICAgYWN0aW9uOiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZV90eXBlOiBzdHJpbmc7XHJcbiAgICByZXNvdXJjZV9pZD86IHN0cmluZztcclxuICAgIGRldGFpbHM/OiBhbnk7XHJcbiAgfSkgPT5cclxuICAgIGFwaVJlcXVlc3QoJy9hdWRpdC1sb2dzJywge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXVkaXREYXRhKSxcclxuICAgIH0pLFxyXG59O1xyXG5cclxuLy8gRXhwb3J0IGFsbCBBUElzXHJcbmV4cG9ydCBjb25zdCBhcGkgPSB7XHJcbiAgdXNlcjogdXNlckFQSSxcclxuICBjb3Vyc2U6IGNvdXJzZUFQSSxcclxuICBjYXRlZ29yeTogY2F0ZWdvcnlBUEksXHJcbiAgaW5zdHJ1Y3RvcjogaW5zdHJ1Y3RvckFQSSxcclxuICBwcm9ncmVzczogcHJvZ3Jlc3NBUEksXHJcbiAgY2VydGlmaWNhdGU6IGNlcnRpZmljYXRlQVBJLFxyXG4gIGFjaGlldmVtZW50OiBhY2hpZXZlbWVudEFQSSxcclxuICBhbmFseXRpY3M6IGFuYWx5dGljc0FQSSxcclxuICBhdWRpdExvZ3M6IGF1ZGl0TG9nc0FQSSxcclxufTsiXSwibmFtZXMiOlsiQVBJX0JBU0VfVVJMIiwiYXBpUmVxdWVzdCIsImVuZHBvaW50Iiwib3B0aW9ucyIsInVybCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRlZmF1bHRPcHRpb25zIiwiaGVhZGVycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJzdGF0dXMiLCJyZW1vdmVJdGVtIiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwiRXJyb3IiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsImVycm9yIiwiZGF0YSIsImNvbnNvbGUiLCJ1c2VyQVBJIiwiZ2V0VXNlcnMiLCJnZXRVc2VyIiwidXNlcklkIiwiZ2V0VXNlckJ5RW1haWwiLCJlbWFpbCIsImNyZWF0ZVVzZXIiLCJ1c2VyRGF0YSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlVXNlciIsImRlbGV0ZVVzZXIiLCJjb3Vyc2VBUEkiLCJnZXRBbGxDb3Vyc2VzIiwiZ2V0Q291cnNlIiwiY291cnNlSWQiLCJnZXRGZWF0dXJlZENvdXJzZXMiLCJnZXRDb3Vyc2VzQnlDYXRlZ29yeSIsImNhdGVnb3J5SWQiLCJjcmVhdGVDb3Vyc2UiLCJjb3Vyc2VEYXRhIiwidXBkYXRlQ291cnNlIiwiZGVsZXRlQ291cnNlIiwiY2F0ZWdvcnlBUEkiLCJnZXRBbGxDYXRlZ29yaWVzIiwiZ2V0Q2F0ZWdvcnkiLCJjcmVhdGVDYXRlZ29yeSIsImNhdGVnb3J5RGF0YSIsInVwZGF0ZUNhdGVnb3J5IiwiZGVsZXRlQ2F0ZWdvcnkiLCJpbnN0cnVjdG9yQVBJIiwiZ2V0QWxsSW5zdHJ1Y3RvcnMiLCJnZXRJbnN0cnVjdG9yIiwiaW5zdHJ1Y3RvcklkIiwiZ2V0SW5zdHJ1Y3RvckNvdXJzZXMiLCJjcmVhdGVJbnN0cnVjdG9yIiwiaW5zdHJ1Y3RvckRhdGEiLCJ1cGRhdGVJbnN0cnVjdG9yIiwiZGVsZXRlSW5zdHJ1Y3RvciIsInByb2dyZXNzQVBJIiwiZ2V0VXNlclByb2dyZXNzIiwiZ2V0QWxsVXNlclByb2dyZXNzIiwidXBkYXRlUHJvZ3Jlc3MiLCJwcm9ncmVzc0RhdGEiLCJjcmVhdGVQcm9ncmVzcyIsImNlcnRpZmljYXRlQVBJIiwiZ2V0VXNlckNlcnRpZmljYXRlcyIsImdldENlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsInZlcmlmeUNlcnRpZmljYXRlIiwidmVyaWZpY2F0aW9uQ29kZSIsImNyZWF0ZUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVEYXRhIiwiYWNoaWV2ZW1lbnRBUEkiLCJnZXRVc2VyQWNoaWV2ZW1lbnRzIiwiY3JlYXRlQWNoaWV2ZW1lbnQiLCJhY2hpZXZlbWVudERhdGEiLCJ1cGRhdGVBY2hpZXZlbWVudFByb2dyZXNzIiwiYWNoaWV2ZW1lbnRJZCIsInByb2dyZXNzIiwiYW5hbHl0aWNzQVBJIiwiZ2V0UGxhdGZvcm1TdGF0cyIsImdldERldGFpbGVkQW5hbHl0aWNzIiwiZ2V0VXNlclN0YXRzIiwiZ2V0Q291cnNlU3RhdHMiLCJhdWRpdExvZ3NBUEkiLCJnZXRBdWRpdExvZ3MiLCJmaWx0ZXJzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImFwcGVuZCIsInRvU3RyaW5nIiwiY3JlYXRlQXVkaXRMb2ciLCJhdWRpdERhdGEiLCJhcGkiLCJ1c2VyIiwiY291cnNlIiwiY2F0ZWdvcnkiLCJpbnN0cnVjdG9yIiwiY2VydGlmaWNhdGUiLCJhY2hpZXZlbWVudCIsImFuYWx5dGljcyIsImF1ZGl0TG9ncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/lib/api.ts\n"));

/***/ })

});